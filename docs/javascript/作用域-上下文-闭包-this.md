## 作用域

> 定义：函数运行时可访问的上下文范围，也就是变量及函数的访问权限，作用域是在预编译阶段形成的。

编译的过程中生成作用域：

- 1、词法/语法分析:将代码块分解成词法单元，如`var a = 1`分解成 `var`、`a`、`=`、`1`。
- 2、解析/语法解析：将分解的词法组成一颗包含各节点信息的抽象语法树(AST)。
- 3、生成代码：将 AST 语法树组成引擎能识别的可执行代码。

相关概念

- 引擎：负责`js`的编译及执行过程。
- 编译器： 负责词法分析及代码生成。
- 作用域：收集和维护所有声明的标识符的查询，执行严格的规则，确定当前执行的代码对这些标识符有访问权限。

注意这里查询上下文的时候有个`LHS`、`RHS`概念

- `LHS` : 左查询，通俗的意思是 对变量赋值查询，如 `var a = 1`这个是对`a`的左查询。
- `RHS` : 右查询 通俗的意思是 对变量读取查询，如 `console.log(a)`这个是对`a`的右查询。

作用域类别：
- `词法作用域`：词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。`eval()`、`with()`可以改变词法作用域，所以不建议使用。

- `函数作用域`：属于这个函数的全部变量都可以在整个函数的范围内使用及复用。

- `块级作用域`：作用范围仅在代码块中，外部无法访问。使用`let`、`with`、`try...catch`可以实现块级作用域（暂时性死区）。

#### 变量提升

> 变量及函数提升会在词法分析阶段进行，函数声明提升优先级大于变量提升，且函数声明会覆盖同名变量声明，函数表达式无法提升。

```js
fn();
var fn;
function fn() {
  console.log(1);
}
fn = function() {
  console.log(2);
};
// 1
```

## 作用域链

> 定义：当访问一个变量时，解释器会先在当前作用域查找标示符，如果没有找到，就去父作用域逐级向上查找，直到找到最顶端的全局对象或者没有（直接报错）为止。作用域链是在函数调用时执行上下文创建阶段生成的。

作用域链第一个对象始终是当前执行代码所在环境的变量对象（VO）。如果是函数执行阶段，那么将其活动对象（AO）作为作用域链第一个对象，第二个对象是上级函数的执行上下文 的变量对象，下一个对象依次类推。

> 作用域链和原型继承查找时的区别：在作用域链中找不到会报错`ReferenceError`，在原型链中找不到会返回`undefined`。


作用域链的几个概念：

#### 函数的生命周期

生命周期分为两个阶段：

  - 创建：函数声明提前，同时将该函数放到全局作用域中或当前函数的上一级函数的局部作用域中。
  - 执行：将当前函数的局部变量和内部函数进行声明提前，然后再执行业务代码，当函数执行完退出时，释放该函数的执行上下文，并注销该函数的局部变量。

####  变量对象（Variable Object）
VO 对应的是函数创建阶段，JS 解析引擎进行预解析时，所有的变量和函数的声明，统称为变量对象。该变量与执行上下文相关，知道自己的数据存储在哪里，并且知道如何访问。`VO`是一个与执行上下文相关的特殊对象，它存储着在上下文中声明的以下内容：
  - 变量 (`var`, 变量声明);
  - 函数声明
  - 函数的形参

#### 活动对象（Activetion Object）
AO 对应的是函数执行阶段，当函数被调用执行时，会建立一个执行上下文，该执行上下文包含了函数所需的所有变量，该变量共同组成了一个新的对象就是活动对象。该对象包含了：
  - 函数的所有局部变量
  - 函数的所有命名参数
  - 函数的参数集合(arguments)
  - 函数的 this 指向



## 闭包

> 定义：当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。通俗的将就是 `定义在函数内部的函数，这个函数可以访问父函数的局部变量`，这种函数就称为闭包。

```js
function fn() {
  var a = 1;
  return function fn_c() {
    console.log(a);
  };
}
var b = fn();
b();
```

举例：函数 `fn` 返回了一个函数 `fn_c`，并且函数 `fn_c` 中使用了函数 `fn` 的变量，那么函数 `fn_c` 就被称为闭包。

注意：函数 `fn` 弹出调用栈执行后，函数 `fn` 中的变量是没有被回收，是存储在堆上的。所以函数 `fn_c` 依旧能引用到函数 `fn` 中的变量，要合理使用闭包，否则会造成内存泄露。

总结：

- 1、是一个函数（比如，内部函数从父函数中返回）。
- 2、能访问上级函数作用域中的变量（哪怕上级函数上下文已经销毁）。

## 执行上下文

函数每调用一次，都会产生一个新的执行上下文环境，当执行代码时，会产生三种执行上下文：

- 全局执行上下文（包含变量、函数声明和函数的形参）
- 函数执行上下文
- eval 执行上下文

执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会执行上下文环境。当函数调用完成时，这个上下文环境以及其中的数据都会被消除（闭包除外），**处于活动状态的执行上下文环境只有一个**，执行过程以入栈出栈的方式。

如例子：

```js
function bar(){
  console.log('bar')
  fn()
}
function fn () {
  console.log('fn')
}
bar()
```

<img src="./images/作用域-上下文-闭包-this/1.png" style="zoom:50%;" />


每个执行上下文中都有三个重要的属性

- 变量对象（VO），包含变量、函数声明和函数的形参，该属性只能在全局上下文中访问
- 作用域链（JS 采用词法作用域，也就是说变量的作用域是在定义时就决定了）
- this


## this

>  概念：this的指向在函数定义阶段是无法确定的，是在函数调用时根据上下文动态决定的。

函数在执行时会创建一个执行上下文，这个上下文包括函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等，同时也会在上下文中记录`this`

所以一句话总结：

> 谁调用这个函数，`this`就指向谁。

注意：箭头函数中的`this`是在函数定义时确定的，非严格模式指向父作用域，严格模式为 undefined。

#### this 绑定的优先级

- 1、由`new`调用，绑定到新生成的对象
- 2、由`apply`、`call`、`bind`显示绑定的`this`，指向绑定的对象
- 3、由对象调用，绑定到调用的对象
- 4、非严格模式下默认绑定到全局对象，严格模式下为`undefined`

注意点：非严格模式下，在 node 环境中，不会将 this 绑定到 global，所以项目代码中，要么使用严格模式要么使用非严格模式，不要混合使用

如例子：

``` js
function demo(){
  console.log(this.a);
}
var a = 1;
demo();
//node 环境中输出 undefined
//浏览器输出 1
```

